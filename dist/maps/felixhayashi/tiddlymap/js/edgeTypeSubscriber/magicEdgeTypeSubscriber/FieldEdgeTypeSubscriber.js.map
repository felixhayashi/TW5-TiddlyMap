{"version":3,"sources":["felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/FieldEdgeTypeSubscriber.js"],"names":["FieldEdgeTypeSubscriber","allEdgeTypes","options","priority","edgeType","namespace","tObj","fieldName","toWL","fields","edge","type","toTRef","tracker","getTiddlerById","to","utils","setField","name","undefined","AbstractMagicEdgeTypeSubscriber"],"mappings":";;;;;;;;;;;AAWA;;;;AACA;;;;;;;;;;+eAZA;AACA;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;IAmBMA,uB;;;AAEJ;;;AAGA,mCAAYC,YAAZ,EAAwC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AAAA,6IAChCD,YADgC,aAChBE,UAAU,EADM,IACCD,OADD;AAEvC;;AAED;;;;;;;8BAGUE,Q,EAAU;;AAElB,aAAOA,SAASC,SAAT,KAAuB,UAA9B;AAED;;AAED;;;;;;2CAGuBC,I,EAAMC,S,EAAWC,I,EAAM;;AAE5C;AACA,aAAO,CAAEF,KAAKG,MAAL,CAAYF,SAAZ,CAAF,CAAP;AAED;;AAED;;;;;;+BAGWD,I,EAAMI,I,EAAMC,I,EAAM;;AAE3B,UAAMC,SAAS,KAAKC,OAAL,CAAaC,cAAb,CAA4BJ,KAAKK,EAAjC,CAAf;AACA,UAAIH,UAAU,IAAd,EAAoB;AAAE;AACpB;AACD;;AAED;AACAI,sBAAMC,QAAN,CAAeX,IAAf,EAAqBK,KAAKO,IAA1B,EAAgCN,MAAhC;;AAEA,aAAOF,IAAP;AAED;;;;;AAED;;;+BAGWJ,I,EAAMI,I,EAAMC,I,EAAM;;AAE3B,UAAMC,SAAS,KAAKC,OAAL,CAAaC,cAAb,CAA4BJ,KAAKK,EAAjC,CAAf;;AAEA,UAAIH,UAAU,IAAd,EAAoB;AAAE;AACpB;AACD;;AAED;AACAI,sBAAMC,QAAN,CAAeX,IAAf,EAAqBK,KAAKO,IAA1B,EAAgCC,SAAhC;;AAEA,aAAOT,IAAP;AAED;;;;EA7DmCU,yC;;AAgEtC;;QAESpB,uB,GAAAA,uB","file":"../../../../../../felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/FieldEdgeTypeSubscriber.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/field\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\nimport utils from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport AbstractMagicEdgeTypeSubscriber from '$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber';\n\n/**\n * The FieldEdgeTypeSubscriber deals with connections that are stored in form of tiddler fields.\n * In this case one field can only hold one connection.\n *\n * If an EdgeType with a \"tw-field\" namespace is inserted or deleted, the type's name\n * is interpreted as field name and the connection is stored or removed in a tiddler\n * field with of that name.\n *\n * E.g. creating an edge between the tiddlers \"Betsy\" and \"Dave\" with the type\n * tw-field:husband will create a field \"husband\" inside the \"Betsy\" tiddler and set\n * \"Dave\" as value.\n\n * Note: A single field can only hold one connection.\n *\n * @see http://tiddlymap.org/#tw-field\n *\n * @inheritDoc\n * @constructor\n */\nclass FieldEdgeTypeSubscriber extends AbstractMagicEdgeTypeSubscriber {\n\n  /**\n   * @inheritDoc\n   */\n  constructor(allEdgeTypes, options = {}) {\n    super(allEdgeTypes, { priority: 10, ...options });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  canHandle(edgeType) {\n\n    return edgeType.namespace === 'tw-field';\n\n  }\n\n  /**\n   * @override\n   */\n  getReferencesFromField(tObj, fieldName, toWL) {\n\n    // wrap in array\n    return [ tObj.fields[fieldName] ];\n\n  }\n\n  /**\n   * Stores and maybe overrides an edge in this tiddler\n   */\n  insertEdge(tObj, edge, type) {\n\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n    if (toTRef == null) { // null or undefined\n      return;\n    }\n\n    // only use the name without the private marker or the namespace\n    utils.setField(tObj, type.name, toTRef);\n\n    return edge;\n\n  };\n\n  /**\n   * Deletes an edge in this tiddler\n   */\n  deleteEdge(tObj, edge, type) {\n\n    const toTRef = this.tracker.getTiddlerById(edge.to);\n\n    if (toTRef == null) { // null or undefined\n      return;\n    }\n\n    // only use the name without the private marker or the namespace\n    utils.setField(tObj, type.name, undefined);\n\n    return edge;\n\n  }\n}\n\n/*** Exports *******************************************************/\n\nexport { FieldEdgeTypeSubscriber };\n"],"sourceRoot":"../../../../../../../src/plugins"}