{"version":3,"sources":["felixhayashi/tiddlymap/js/graph/ViewAbstraction.js"],"names":["_EdgeType","require","_utils","_environment","env","_exception","ViewAbstraction","view","options","arguments","length","undefined","_classCallCheck","this","_registerPaths","isCreate","configTRef","name","_utils2","default","getRandomLabel","plural","$tw","wiki","generateNewTitle","$tm","path","views","_createView","exists","getRoot","ResourceNotFoundException","_rebuildCache","updates","changedTiddlers","edgeTypes","hasKeyWithPrefix","tiddler","cp","getTiddler","snapshotTRef","asString","date","fields","Date","utils","formatDateString","getBasename","deleteTiddlers","getMatches","filter","getLabel","newLabel","inArray","notify","oldLabel","newRoot","oldRoot","mv","config","sys","defaultView","setEntry","ref","sysUserConf","liveTab","fallbackView","each","tObj","tRef","setField","nodes","getNodeData","id","saveNodeData","isTrue","getConfig","getPropertiesByPrefix","prefixlessName","startsWith","_len","args","Array","_key","_typeof","prop","setConfig","isRebuild","getWithoutPrefix","val","logger","match","Function","prototype","bind","apply","InvalidArgumentException","concat","addTiddler","Tiddler","misc","liveViewLabel","node","regex","escapeRegExp","_getNodeIdFilterPart","expr","force","replace","getNodeFilter","isLiveView","nodeFilterTRef","nodeFilter","getEdgeTypeFilter","edgeTypeFilterTRef","edgeTypeFilter","_isNodeIncludedById","separator","setNodeFilter","part","saveNodePosition","nodeId","f","nodeData","type","allETy","indeces","src","Object","keys","raw","pretty","getPrettyFilter","matches","getEdgeTypeMatches","whitelist","getLookupTable","isEdgeTypeMatch","_EdgeType2","getInstance","makeHashMap","data","parseFieldData","mapTRef","_len2","_key2","assign","writeFieldData","jsonIndentation","x","y","positions","style","pos","p","_extends","_ref","isForce","protoView","isHidden","destroy","title","genUUID","field","viewMarker","setEdgeTypeFilter","defaultEdgeTypeFilter","label","_getRootPath","tiddlerExists"],"mappings":"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","file":"../../../../../felixhayashi/tiddlymap/js/graph/ViewAbstraction.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nimport EdgeType from '$:/plugins/felixhayashi/tiddlymap/js/EdgeType';\nimport utils    from '$:/plugins/felixhayashi/tiddlymap/js/utils';\nimport * as env from '$:/plugins/felixhayashi/tiddlymap/js/lib/environment';\nimport {\n  InvalidArgumentException,\n}               from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/*** Code **********************************************************/\n\n/**\n * This class abstracts the various pieces that together make up the\n * view such as map, edge filter, node filter, config etc.\n * If {@code isCreate} is not specified, the viewAbstraction will only\n * represent the view and not create it or any missing part of it.\n */\nclass ViewAbstraction {\n\n  /**\n   *\n   * @param {string|ViewAbstraction|Tiddler} view - The view\n   * @param {Object} options\n   * @param {boolean} [options.isCreate] - True if the view should be created and override\n   *     any existing view, false otherwise.\n   */\n  constructor(view, options = {}) {\n\n    if (view instanceof ViewAbstraction) {\n\n      // bounce back the object we received\n      return view;\n\n    }\n\n    this._registerPaths(view);\n\n    if (options.isCreate) {\n\n      if (!this.configTRef) {\n\n        const name = utils.getRandomLabel({plural: true});\n        this.configTRef = $tw.wiki.generateNewTitle(`${$tm.path.views}/${name}`);\n\n      }\n\n      this._createView(options);\n\n    } else if (!ViewAbstraction.exists(this.getRoot())) { // no valid config path\n\n      throw new ResourceNotFoundException('ViewAbstraction', view);\n\n    }\n\n    // force complete rebuild\n    this._rebuildCache();\n\n  }\n\n  /**\n   * Returns true if this view cannot be edited.\n   * As a general rule, all views that come as plugins are locked.\n   *\n   * @return {boolean}\n   */\n  isLocked() {\n\n    return $tw.wiki.isShadowTiddler(this.configTRef);\n\n  }\n\n  /**\n   * Gives the view a chance to rebuild its properties cache.\n   *\n   * @param {Updates} updates\n   * @return {boolean} True if changes affect parts of the view.\n   */\n  update(updates) {\n\n    const { changedTiddlers } = updates;\n\n    if (updates[env.path.edgeTypes] || utils.hasKeyWithPrefix(changedTiddlers, this.getRoot())) {\n\n      this._rebuildCache();\n\n      return true;\n    }\n\n    return false;\n\n  }\n\n  /**\n   * clones the tiddler denoted via tRef and uses it as placeholder\n   * for this view when a widget using this view is displayed in\n   * static mode\n   *\n   * @param {Tiddler} tiddler\n   */\n  addPlaceholder(tiddler) {\n\n    utils.cp(utils.getTiddler(tiddler), this.snapshotTRef, true);\n\n  }\n\n  /**\n   * A view exists if the the view's root exists as tiddler in the store.\n   *\n   * @deprecated\n   *\n   * @return {boolean}\n   */\n  exists() {\n\n    return ViewAbstraction.exists(this);\n\n  }\n\n  /**\n   * The path to the config tiddler that represents the view.\n   *\n   * @return {TiddlerReference}\n   */\n  getRoot() {\n\n    return this.configTRef;\n\n  }\n\n  /**\n   * Returns this view's creation date.\n   *\n   * @param {boolean} [asString] True if the returned value should be a string in any case.\n   * @return {string|object|undefined} The creation date in the specified output format.\n   */\n  getCreationDate(asString) {\n\n    const date = $tw.wiki.getTiddler(this.configTRef).fields['created'];\n\n    if (asString) {\n      // note: th will be translated as well!\n      return (date instanceof Date ? $tw.utils.formatDateString(date, 'DDth MMM YYYY') : '');\n    }\n\n    return date;\n\n  }\n\n  /**\n   * The label of the view (which is basically the root-path's basename).\n   *\n   * @return {string} The label (name) of the view.\n   */\n  getLabel() {\n\n    return utils.getBasename(this.configTRef);\n\n  }\n\n  /**\n   * Method to remove the view and its configuration.\n   * It will make the view non-existent.\n   *\n   * Note: Do not use the object anymore after you called this function!\n   */\n  destroy() {\n\n    // delete the view and all tiddlers stored in its path (map, edge-filter etc.)\n    utils.deleteTiddlers(utils.getMatches(`[prefix[${this.configTRef}]]`));\n\n  }\n\n  /**\n   * Returns all tiddlers include tiddlymap widgets that reference this view.\n   */\n  getOccurrences() {\n\n    const filter = `[regexp:text[<\\\\$(tiddlymap|tmap).*?view=.${this.getLabel()}..*?>]]`;\n    return utils.getMatches(filter);\n\n  }\n\n  /**\n   * Renames the view.\n   *\n   * @param {string} newLabel\n   * @return {boolean}\n   */\n  rename(newLabel) {\n\n    if (typeof newLabel !== 'string') {\n\n      return false;\n    }\n\n    if (utils.inArray('/', newLabel)) {\n\n      $tm.notify('A view name must not contain any \"/\"');\n\n      return false;\n    }\n\n    // keep a reference to the old label before we change it\n    const oldLabel = this.getLabel();\n\n    // start the renaming\n    const newRoot = env.path.views + '/' + newLabel;\n    const oldRoot = this.getRoot();\n\n    utils.mv(oldRoot, newRoot, true);\n\n    // update references\n\n    if ($tm.config.sys.defaultView === oldLabel) {\n      utils.setEntry($tm.ref.sysUserConf, 'defaultView', newLabel);\n    }\n\n    if ($tm.config.sys.liveTab.fallbackView === oldLabel) {\n      utils.setEntry($tm.ref.sysUserConf, 'liveTab.fallbackView', newLabel);\n    }\n\n    $tw.wiki.each((tObj, tRef) => {\n\n      if (tObj.fields['tmap.open-view'] === oldLabel) {\n\n        // update global node data fields referencing this view\n        utils.setField(tRef, 'tmap.open-view', newLabel);\n\n        return;\n\n      }\n\n      if (ViewAbstraction.exists(tRef)) {\n\n        // update all local node data referencing this view\n        const view = new ViewAbstraction(tRef);\n        const nodes = view.getNodeData();\n\n        for (let id in nodes) {\n          if (nodes[id]['open-view'] === oldLabel) {\n            nodes[id]['open-view'] = newLabel;\n          }\n        }\n\n        view.saveNodeData(nodes);\n\n      }\n\n    });\n\n    this._registerPaths(newLabel);\n    this._rebuildCache();\n\n  }\n\n  /**\n   * All configurations that are toggled via checkboxes to have a value\n   * either `true` or `false` can be accessed via this method.\n   *\n   * @param {string} name - The configs name without the `_config` prefix.\n   * @return {boolean} True if the configuration is enabled, false otherwise.\n   */\n  isEnabled(name) {\n\n    return utils.isTrue(this.getConfig(name), false);\n\n  }\n\n  /**\n   * Returns a configuration value relating to the given name. If no name\n   * is given, an object with all configurations is returned.\n   *\n   * @param {string} [name] - Instead of all configurations being returned,\n   *     only the configuration named name is returned. The initial \"config.\"\n   *     may be omitted.\n   * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\n   * @result {string|Object} If `type` is not specified an object containing\n   *     all configurations is returned, otherwise a single value will be returned.\n   */\n  getConfig(name, isRebuild) {\n\n    let config;\n\n    if (!isRebuild && this.config) {\n\n      config = this.config;\n\n    } else {\n\n      const fields = utils.getTiddler(this.configTRef).fields;\n      config = utils.getPropertiesByPrefix(fields, 'config.');\n\n    }\n\n    const prefixlessName = name && utils.startsWith(name, 'config.') ? name : `config.${name}`;\n\n    return (name ? config[prefixlessName] : config);\n\n  }\n\n  /**\n   * Enables the api user to modify the view's configuration.\n   *\n   * In case two arguments are provided, the first is assumed to be the property\n   * name and the second the value to be set.\n   *\n   * In case a single object is provided as argument, it is treated as a key-value\n   * collection and each property in this object is saved as config.\n   *\n   * @param {*} args\n   */\n  setConfig(...args) {\n\n    if (args[0] == null) { // null or undefined\n\n      return;\n    }\n\n    if (args.length === 1 && typeof args[0] === 'object') {\n\n      for (let prop in args[0]) {\n        this.setConfig(prop, args[0][prop]);\n      }\n\n    } else if (args.length === 2 && typeof args[0] === 'string') {\n\n      const prop = utils.getWithoutPrefix(args[0], 'config.');\n      let val = args[1];\n\n      if (val === undefined) {\n\n        return;\n      }\n\n      if (val === null) {\n\n        $tm.logger('debug', 'Removing config', prop);\n        delete this.config[`config.${prop}`];\n\n      } else {\n\n        if (prop === 'edge_type_namespace') {\n          const match = val.match(/[^:]+/);\n          val = (match ? match[0] : '');\n        }\n\n      }\n\n      $tm.logger('log', 'Setting config', prop, val);\n      this.config[`config.${prop}`] = val;\n\n\n    } else { // not allowed\n\n      throw new InvalidArgumentException(...args);\n\n    }\n\n    // save\n    $tw.wiki.addTiddler(new $tw.Tiddler(\n      utils.getTiddler(this.configTRef),\n      this.config\n    ));\n\n  }\n\n  /**\n   * Whether this view represents the 'live view'\n   *\n   * @return {boolean}\n   */\n  isLiveView() {\n\n    return (this.getLabel() === $tm.misc.liveViewLabel);\n\n  }\n\n  /**\n   * Whether the node is already explicitly contained in the view's node filter,\n   * i.e. whether it is explicitly referenced by its title.\n   *\n   * @private\n   *\n   * @param {Node} node\n   * @return {string}\n   */\n  _isNodeIncludedById(node) {\n\n    const regex = $tw.utils.escapeRegExp(ViewAbstraction._getNodeIdFilterPart(node));\n\n    return this.getNodeFilter('raw').match(regex);\n\n  }\n\n  /**\n   * Sets and rebuilds the node filter according to the expression provided.\n   *\n   * @param {string} expr - A tiddlywiki filter expression.\n   * @param {boolean} force\n   */\n  setNodeFilter(expr, force) {\n\n    expr = expr.replace(/[\\n\\r]/g, ' ');\n\n    if (this.getNodeFilter('raw') === expr) {\n      // already up to date;\n      // This check is critical to prevent recursion!\n      return;\n    }\n\n    if (this.isLiveView() && !force) {\n\n      $tm.notify('You must not change the live view\\'s node filter!');\n\n      return;\n    }\n\n    utils.setField(this.nodeFilterTRef, 'filter', expr);\n\n    $tm.logger('debug', 'Node filter set to', expr);\n\n    // this register new filter\n    this.nodeFilter = this.getNodeFilter(null, true);\n\n  }\n\n  /**\n   * Sets and rebuilds the edge type filter according to the expression provided.\n   *\n   * @param {string} expr - A tiddlywiki filter expression.\n   */\n  setEdgeTypeFilter(expr) {\n\n    expr = expr.replace(/[\\n\\r]/g, ' ');\n\n    if (this.getEdgeTypeFilter('raw') === expr) { // already up to date\n      // This check is critical to prevent recursion!\n      return;\n    }\n\n    utils.setField(this.edgeTypeFilterTRef, 'filter', expr);\n\n    $tm.logger('debug', 'Edge filter set to', expr);\n\n    // this register new filter\n    this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\n\n  }\n\n  /**\n   * Method to append a filter part to the current filter (*or*-style).\n   * The node's tmap.id will be used in the filter to reference the corresponding tiddler.\n   *\n   * @param {Node} node\n   */\n  addNode(node) {\n\n    if (!this._isNodeIncludedById(node)) {\n\n      const part = ViewAbstraction._getNodeIdFilterPart(node);\n      const separator = ' ';\n      this.setNodeFilter(this.getNodeFilter('raw') + separator + part);\n\n      this.saveNodePosition(node);\n    }\n\n  }\n\n  /**\n   * Removes a node from the the view filter that has been\n   * explicitly added before.\n   *\n   * ATTENTION: Never remove the node data (i.e. style and positions)\n   * from the node-data store. This will be done by a garbage\n   * collector. See Adapter.prototype._removeObsoleteViewData\n   *\n   * @return {boolean} True if node was removed, false otherwise.\n   *     Note: false is also returned if the node did not exist before.\n   */\n  removeNode(nodeId) {\n\n    if (!this._isNodeIncludedById(nodeId)) {\n\n      return false;\n    }\n\n    const part = ViewAbstraction._getNodeIdFilterPart(nodeId);\n    const f = this.getNodeFilter('raw').replace(part, '');\n\n    this.setNodeFilter(f);\n\n    if (this.nodeData[nodeId]) {\n      this.saveNodeData(nodeId, null);\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Method will return a tiddlywiki edge-type filter that is used to\n   * decide which edge types are displayed by the graph.\n   *\n   * Note: needs to be recalculated if the collection of edge types changed\n   * in the wiki.\n   *\n   * @param {(\"raw\"|\"pretty\"|\"matches\"|\"whitelist\")} [type]\n   *     Use this param to control the output type.\n   * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\n   * @result {*}\n   *     Depends on the type param:\n   *     - raw: the original filter string\n   *     - pretty: the prettyfied filter string for usage in textareas\n   *     - matches: {Array<string>} all matches\n   *     - whitelist: A lookup table where all matches are true\n   */\n  getEdgeTypeFilter(type, isRebuild) {\n\n    let filter;\n\n    if (!isRebuild && this.edgeTypeFilter) {\n\n      filter = this.edgeTypeFilter;\n\n    } else {\n\n      const allETy = $tm.indeces.allETy;\n      const src = Object.keys(allETy);\n      const tObj = $tw.wiki.getTiddler(this.edgeTypeFilterTRef);\n\n      filter = {};\n      filter.raw = (tObj && tObj.fields.filter || '');\n      filter.pretty = utils.getPrettyFilter(filter.raw);\n      filter.matches = utils.getEdgeTypeMatches(filter.raw, allETy);\n      filter.whitelist = utils.getLookupTable(filter.matches);\n\n    }\n\n    return (type ? filter[type] : filter);\n\n  }\n\n  /**\n   * Whether or not this EdgeType is visible in this view.\n   *\n   * @param {EdgeType|string} id\n   * @return {*}\n   */\n  isEdgeTypeVisible(id) {\n\n    return utils.isEdgeTypeMatch(EdgeType.getInstance(id).id, this.edgeTypeFilter.raw);\n\n  }\n\n  /**\n   * Method will return a tiddlywiki node filter that is used to\n   * decide which nodes are displayed by the graph.\n   *\n   * @param {(\"raw\"|\"pretty\"|\"compiled\")} [type] - Use this param to control the output type.\n   * @param {boolean} [isRebuild=false] - True if to rebuild the cache, false otherwise.\n   * @result {*}\n   *     Depends on the type param:\n   *     - raw: the original filter string\n   *     - pretty: the prettyfied filter string for usage in textareas\n   *     - compiled: {Array<string>} all matches\n   */\n  getNodeFilter(type, isRebuild = false) {\n\n    let filter;\n\n    if (!isRebuild && this.nodeFilter) {\n\n      filter = this.nodeFilter;\n\n    } else {\n\n      filter = utils.makeHashMap();\n      const tObj = $tw.wiki.getTiddler(this.nodeFilterTRef);\n\n      filter.raw = (tObj && tObj.fields.filter) || '';\n      filter.pretty = utils.getPrettyFilter(filter.raw);\n      filter.compiled = $tw.wiki.compileFilter(filter.raw);\n\n    }\n\n    return (type ? filter[type] : filter);\n\n  }\n\n  /**\n   * This method will return the node data stored in the view.\n   *\n   * @todo When to delete obsolete data?\n   *\n   * @param {string} nodeId\n   * @param {boolean} [isRebuild] - True if to rebuild the cache, false otherwise.\n   * @result {Hashmap<Id, Object>} A Hashmap with node data.\n   */\n  getNodeData(nodeId, isRebuild) {\n\n    const data = (!isRebuild && this.nodeData\n      ? this.nodeData\n      : utils.parseFieldData(this.mapTRef, 'text', {}));\n\n    return (nodeId ? data[nodeId] : data);\n\n  }\n\n  /**\n   * A view equals another view either\n   *\n   * 1) if the js objects reference the same objects in the js runtime\n   * 2) or if the views have the same root and both views exist\n   *\n   * @param view\n   * @return {boolean}\n   */\n  equals(view) {\n\n    return view === this\n      || (ViewAbstraction.exists(view) && (new ViewAbstraction(view)).getRoot() === this.getRoot());\n\n  }\n\n  /**\n   * This function will merge the given data in the view's node store.\n   *\n   * If a property is set to null, it will be removed.\n   *\n   * If two arguments are provided, the first parameter is assumed\n   * to be a node id and the second to be the data object. The data\n   * will extend the existing data. If data is not an object, it is\n   * assumed to be a delete directive and consequently the node data\n   * in the store will be deleted.\n   *\n   * Otherwise, if a single object parameter is provided, it is regarded\n   * as a node collection and the whole object is used to extend the store.\n   *\n   * Note: The Adapter will routinely delete node content of nodes that are\n   * not contained in the view anymore.\n   */\n  saveNodeData(...args) {\n\n    const data = this.getNodeData();\n\n    if (args.length === 2) {\n\n      if (typeof args[1] === 'object') {\n\n        if (args[1] === null) {\n\n          delete data[args[0]];\n\n        } else {\n\n          data[args[0]] = Object.assign(data[args[0]] || {}, args[1]);\n        }\n      }\n\n    } else if (args.length === 1 && typeof args[0] === 'object') {\n\n      $tm.logger('log', 'Storing data in', this.mapTRef);\n\n      Object.assign(data, args[0]);\n\n    } else { // not allowed\n\n      throw new InvalidArgumentException(...args);\n    }\n\n    utils.writeFieldData(this.mapTRef, 'text', data, $tm.config.sys.jsonIndentation);\n\n    // register new values\n    this.nodeData = data;\n\n  }\n\n  /**\n   * Saves a node's position to the store\n   *\n   * @param {Node} node\n   */\n  saveNodePosition(node) {\n\n    if (node.id && node.x != null && node.y != null) {\n      // only pass coordinates to prevent other data from being stored!\n      this.saveNodeData(node.id, { x: node.x, y: node.y });\n    }\n\n  }\n\n  /**\n   * Saves a node's position to the store\n   *\n   * @param {Object} positions\n   */\n  saveNodePositions(positions) {\n\n    const { nodeData } = this;\n\n    for (let id in positions) {\n\n      nodeData[id] = nodeData[id] || {};\n      nodeData[id].x = positions[id].x;\n      nodeData[id].y = positions[id].y;\n\n    }\n\n    this.saveNodeData(nodeData);\n\n  }\n\n  /**\n   * Marks the node with the given id as central topic.\n   *\n   * @param nodeId\n   */\n  setCentralTopic(nodeId) {\n\n    this.setConfig('central-topic', nodeId);\n\n  }\n\n  /**\n   * Saves the provided style for the node with the specified id in the view's store.\n   *\n   * Note: The coordinates of the node on the map are not stored via this function.\n   * For this task, use saveNodePosition() instead.\n   *\n   * @param {string} nodeId\n   * @param {Object} style\n   */\n  saveNodeStyle(nodeId, style) {\n\n    // remove any previos style from store;\n    // @TODO: optimize this only null in style var needs to be removed\n    const data = this.getNodeData(nodeId) || {};\n\n    const pos = { x: data.x, y: data.y };\n\n    // tabula rasa! delete all previous properties\n    for (let p in data) {\n      delete data[p];\n    }\n\n    // save new style\n    this.saveNodeData(nodeId, {\n      ...style,\n      ...pos\n    });\n\n  }\n\n  /**\n   * The view's configTiddlerRef is stored in different tiddlers (paths).\n   * This function registers these paths to this the view instance.\n   *\n   * @private\n   * @params {ViewAbstraction|string} view\n   */\n  _registerPaths(view, isCreate) {\n\n    // main config is stored here\n    this.configTRef = ViewAbstraction._getRootPath(view);\n\n    // store for node properties (positions and local node styles)\n    this.mapTRef = `${this.configTRef}/map`;\n\n    // filter stores\n    this.nodeFilterTRef = `${this.configTRef}/filter/nodes`;\n    this.edgeTypeFilterTRef = `${this.configTRef}/filter/edges`;\n\n    this.snapshotTRef = `${this.getRoot()}/snapshot`;\n\n  }\n\n  /**\n   * Will create the config tiddler which means that the view will\n   * start to exist.\n   *\n   * @private\n   */\n  _createView({ isForce, protoView, isHidden } = {}) {\n\n    // destroy any former view that existed in this path\n    if (ViewAbstraction.exists(this)) {\n\n      if (!isForce) {\n\n        return;\n\n      }\n\n      this.destroy();\n    }\n\n    if (ViewAbstraction.exists(protoView)) {\n      utils.cp((new ViewAbstraction(protoView)).getRoot(), this.configTRef, true);\n    }\n\n    // create new view\n    const fields = {\n      title: this.configTRef,\n      id: utils.genUUID(), // maybe useful for future purposesâ€¦\n    };\n\n    if (!isHidden) {\n      fields[$tm.field.viewMarker] = true;\n    }\n\n    $tw.wiki.addTiddler(new $tw.Tiddler(\n      utils.getTiddler(this.configTRef), // in case we cloned the view\n      fields\n    ));\n\n    this.setEdgeTypeFilter(env.filter.defaultEdgeTypeFilter);\n\n  }\n\n  /**\n   * This method will rebuild the cache.\n   *\n   * @private\n   * @return {boolean} true if the cache was dirty, false if cache was up-to-date and did\n   */\n  _rebuildCache() {\n\n    this.config = this.getConfig(null, true);\n    this.nodeData = this.getNodeData(null, true);\n    this.nodeFilter = this.getNodeFilter(null, true);\n    this.edgeTypeFilter = this.getEdgeTypeFilter(null, true);\n\n  }\n\n  /**\n   * Will return a filter part that matches the node's id.\n   *\n   * E.g. [field:tmap.id[1748576e-74bb-4165-85bb-0d312e3e4f1f]]\n   *\n   * @private\n   *\n   * @param node\n   * @return {string}\n   */\n  static _getNodeIdFilterPart(node) {\n\n    const id = (typeof node === 'object' ? node.id : node);\n\n    return `[field:tmap.id[${id}]]`;\n\n  }\n\n  /**\n   * Will return the path to the config tiddler of this view, aka the view's root.\n   *\n   * @private\n   *\n   * @param {*} view - The constructor param to abstract or create the view.\n   * @result {string|undefined} The view config path.\n   */\n  static _getRootPath(view) {\n\n    if (view instanceof ViewAbstraction) {\n\n      return view.configTRef;\n\n    }\n\n    if (view instanceof $tw.Tiddler) { // is a tiddler object\n\n      view  = view.fields.title;\n\n    }\n\n    if (typeof view === 'string') {\n\n      // remove prefix and slash\n      const label = utils.getWithoutPrefix(view, `${$tm.path.views}/`);\n\n      // a valid label must not contain any slashes\n      if (label && !utils.hasSubString(label, '/')) {\n\n        return `${$tm.path.views}/${label}`;\n\n      }\n    }\n\n  }\n\n  /**\n   * A view exists if the the view's root exists as tiddler in the store.\n   *\n   * @return {ViewAbstraction|string}\n   */\n  static exists(view) {\n\n    if (!view) {\n\n      return false;\n    }\n\n    if (view instanceof ViewAbstraction) {\n\n      view = view.configTRef;\n\n    } else {\n\n      view = ViewAbstraction._getRootPath(view);\n    }\n\n    return utils.tiddlerExists(view);\n\n  }\n\n}\n\n/*** Exports *******************************************************/\n\nexport default ViewAbstraction;\n"],"sourceRoot":"../../../../../../src/plugins"}