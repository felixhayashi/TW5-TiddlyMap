{"version":3,"sources":["felixhayashi/tiddlymap/js/lib/utils/basic.js"],"names":["ucFirst","string","toUpperCase","slice","hasElements","Object","keys","obj","length","escapeRegex","str","replace","getBasename","path","separator","substring","lastIndexOf","startsWith","prefix","base64","window","Buffer","toString","btoa","bind","identity","JSON","stringify","sort","map","key","isEqual","obj1","obj2","getRandomInt","min","max","Math","floor","random","inArray","needle","haystack","indexOf","hasSubString","sub","parseJSON","data","parse","Error","joinAndWrap","arr","left","right","join","getWithoutNewLines","makeHashMap","create","defineProperty","enumerable","configurable","writable","value","prototype","hasOwnProperty","initialValues","getAncestorWithClass","el","className","parentNode","document","classList","contains","findAndRemoveClassNames","classNames","i","elements","getElementsByClassName","j","remove","isInteger","Number","isFinite","replaceAll","defaultReplacement","subStrings","subString","replacement","Array","isArray","isTrue","confVal","defVal","n","parseInt","isNaN","removeArrayElement","index","splice","getPropertiesByPrefix","removePrefix","r","p","substr","getWithoutPrefix","hasKeyWithPrefix","pickRandom","getImgFromWeb","imgUri","callback","xhr","XMLHttpRequest","open","responseType","onerror","e","console","log","onload","readyState","status","response","size","blob","URL","createObjectURL","send","getFirstElementByClassName","cls","root","isRequired","text","EnvironmentError","getRandomLabel","options","adjective","noun","object","plural","_merge","dest","src","merge","sources","l","setDomListeners","task","target","listeners","isCapt","event","removeDOMChildNodes","childNodes","removeChild","mod","divident","divisor","remainder","getNearestRasterPosition","raster","x","y","rasterHalf","distPrevX","distPrevY","bindTo","context","fnNames","fn"],"mappings":"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","file":"../../../../../../felixhayashi/tiddlymap/js/lib/utils/basic.js","sourcesContent":["// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nimport {\n  EnvironmentError\n} from '$:/plugins/felixhayashi/tiddlymap/js/exception';\n\n/**\n * Uppercase the first letter of a string.\n */\nexport const ucFirst = string => string && string[0].toUpperCase() + string.slice(1);\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nexport const hasElements = obj => Object.keys(obj).length > 0;\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nexport const escapeRegex = str => str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nexport const getBasename = (path, separator = '/') => path.substring(path.lastIndexOf(separator) + 1);\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nexport const startsWith = (str, prefix) => str.substring(0, prefix.length) === prefix;\n\n/**\n * Converts a string to base64 encoding.\n *\n * To do so, we either choose the native btoa browser function or the Buffer class\n * received via scope.\n *\n * @param {string} str\n */\nexport const base64 = typeof window === 'undefined'\n  ? (str => (new Buffer(str)).toString('base64'))\n  : window.btoa.bind(window);\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nexport const identity = obj =>\n  (typeof obj === 'object' && obj !== null\n    ?  JSON.stringify(Object.keys(obj).sort().map(key => [ key, obj[key] ]))\n    : null);\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nexport const isEqual = (obj1, obj2) => identity(obj1) === identity(obj2);\n\n/**\n *\n * @param min\n * @param max\n */\nexport const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nexport const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;\n\n/**\n * Checks if a string exists in a string.\n */\nexport const hasSubString = (str, sub) => str.indexOf(sub) !== -1;\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nexport const parseJSON = (str, data) => {\n\n  try {\n\n    return JSON.parse(str);\n\n  } catch (Error) {\n\n    return data;\n\n  }\n\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nexport const joinAndWrap = (arr, left, right, separator = ' ') =>\n  left + arr.join(right + separator + left) + right;\n\n/**\n * Remove any newline from a string\n */\nexport const getWithoutNewLines = str =>\n  (typeof str === 'string') ? str.replace(/[\\n\\r]/g, ' ') : str;\n\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nexport const makeHashMap = initialValues => {\n\n  const map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (let key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nexport const getAncestorWithClass = (el, className) => {\n\n  if (typeof el !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nexport const findAndRemoveClassNames = function(classNames) {\n\n  for (let i = classNames.length; i--;) {\n    const elements = document.getElementsByClassName(classNames[i]);\n    for (let j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nexport const isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n         isFinite(value) &&\n         Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nexport const replaceAll = (str, defaultReplacement = '', subStrings) => {\n\n  for (let i = subStrings.length; i--;) {\n\n    let subString = subStrings[i];\n    let replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nexport const isTrue = (confVal, defVal) => {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return (isNaN(n) ? (confVal === 'true') : (n !== 0));\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return (n !== 0);\n  }\n\n  return false;\n\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nexport const removeArrayElement = (arr, el) => {\n\n  const index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nexport const getPropertiesByPrefix = (obj, prefix, removePrefix) => {\n\n  const r = makeHashMap();\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      r[(removePrefix ? p.substr(prefix.length) : p)] = obj[p];\n    }\n  }\n\n  return r;\n\n};\n\n/**\n * Function to remove the prefix of a string\n */\nexport const getWithoutPrefix =\n  (str, prefix) => startsWith(str, prefix) ? str.substr(prefix.length) : str;\n\n\n/**\n *\n */\nexport const hasKeyWithPrefix = (obj, prefix) => {\n\n  for (let p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n\n};\n\n/**\n *\n * @param arr\n */\nexport const pickRandom = arr => arr[getRandomInt(0, arr.length-1)];\n\n/**\n * Loads the image from web and passes it to the callback as\n * object url.\n */\nexport const getImgFromWeb = (imgUri, callback) => {\n\n  if (!imgUri || typeof callback !== 'function') return;\n\n  const xhr = new XMLHttpRequest();\n  xhr.open('GET', imgUri, true);\n  xhr.responseType = 'blob';\n  xhr.onerror = function(e) { console.log(e); };\n  xhr.onload = function(e) {\n    if (this.readyState === 4 && (this.status===200 || (this.status === 0 && this.response.size > 0))) {\n      const blob = this.response;\n      callback(window.URL.createObjectURL(blob));\n    }\n  };\n\n  try { xhr.send();  } catch (e) { console.log(e); }\n\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n  //~ propPath = propPath.split(\".\");\n  //~ for (var i = propPath.length; i--;) {\n    //~ if (obj !== null && typeof obj === \"object\") {\n      //~ obj = obj[propPath[i]];\n  //~ }\n  //~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nexport const getFirstElementByClassName = (cls, root, isRequired) => {\n\n  const el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    const text = `Missing element with class \"${cls}\" inside ${root}`;\n    throw new EnvironmentError(text);\n  }\n\n  return el;\n\n};\n\nexport const getRandomLabel = (options = {}) => {\n\n  const adjective = pickRandom([\n    'exciting', 'notable', 'epic', 'new', 'fancy',\n    'great', 'cool', 'fresh', 'funky', 'clever'\n  ]);\n\n  const noun = (options.object || pickRandom([\n    'concept', 'idea', 'thought', 'topic', 'subject'\n  ])) + (options.plural ? 's' : '');\n\n  return `My ${adjective} ${noun}`;\n\n};\n\nconst _merge = (dest, src) => {\n\n  if (typeof dest !== 'object') {\n    dest = {};\n  }\n\n  for (let p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) { // skip null or undefined\n        dest[p] = (typeof src[p] === 'object'\n          ? _merge(dest[p], src[p])\n          : src[p]); // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nexport const merge = (dest, ...sources) => {\n\n  // start the merging; i = 1 since first argument is the destination\n  for (let i = 0, l = sources.length; i < l; i++) {\n    const src = sources[i];\n    if (src != null && typeof src === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nexport const setDomListeners = (task, target, listeners, isCapt) => {\n\n  isCapt = (typeof isCapt === 'boolean' ? isCapt : false);\n  task = task + 'EventListener';\n\n  for (let event in listeners) {\n\n    const l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else { // expect Array\n\n      target[task](event, l[0], (typeof l[1] === 'boolean' ? l[1] : isCapt));\n    }\n\n  }\n\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nexport const removeDOMChildNodes = el => {\n\n  for (let i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nexport const mod = (divident, divisor) => {\n\n  const remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nexport const getNearestRasterPosition = ({ x, y }, raster) => {\n\n  const rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  const distPrevX = mod(x, raster);\n  const distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nexport const bindTo = (context, fnNames) => {\n\n  for (let i = fnNames.length; i--;) {\n    const fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n\n};\n"],"sourceRoot":"../../../../../../../src/plugins"}