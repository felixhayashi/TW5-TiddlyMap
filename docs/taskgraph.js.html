<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>TW-Taskgraph Source: taskgraph.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.spacelab.css">

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top navbar-inverse">
		<div class="navbar-inner">
			<a class="brand" href="index.html">TW-Taskgraph</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="utils.html">utils</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="Adapter.html">Adapter</a>
						</li>
						
						<li>
							<a href="ViewAbstraction.html">ViewAbstraction</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: taskgraph.js</h1>
    
<section>
	<article>
		<pre
			class="sunlight-highlight-javascript linenums">/*\

title: $:/plugins/felixhayashi/taskgraph/taskgraph.js
type: application/javascript
module-type: widget

@preserve

\*/

(function(){

  /*jslint node: true, browser: true */
  /*global $tw: false */
  
  "use strict";
  
  /**************************** IMPORTS ****************************/
   
  var Widget = require("$:/core/modules/widgets/widget.js").widget;
  var ViewAbstraction = require("$:/plugins/felixhayashi/taskgraph/view_abstraction.js").ViewAbstraction;
  var CallbackRegistry = require("$:/plugins/felixhayashi/taskgraph/callback_registry.js").CallbackRegistry;
  var DialogManager = require("$:/plugins/felixhayashi/taskgraph/dialog_manager.js").DialogManager;
  var utils = require("$:/plugins/felixhayashi/taskgraph/utils.js").utils;
  var vis = require("$:/plugins/felixhayashi/vis/vis.js");

  /***************************** CODE ******************************/
        
  /**
   * @constructor
   */
  var TaskGraphWidget = function(parseTreeNode, options) {
    
    // Main initialisation inherited from widget.js
    this.initialise(parseTreeNode, options);
    
    // create shortcuts and aliases
    this.adapter = $tw.taskgraph.adapter;
    this.opt = $tw.taskgraph.opt;
    
    // key (a tiddler) -> callback (called when tiddler changes)
    this.callbackRegistry = new CallbackRegistry();
    this.dialogManager = new DialogManager(this, this.callbackRegistry);
        
    // https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/widgets/widget.js#L211
    this.computeAttributes();
    
    // register whether in editor mode or not
    this.editorMode = this.getAttribute("editor");
    
    if(this.editorMode) {
      // addEventListeners automatically binds "this" object to handler, thus, no need for .bind(this)
      this.addEventListeners([
        {type: "tm-create-view", handler: function() { this.handleCreateView(null); }},
        {type: "tm-rename-view", handler: this.handleRenameView },
        {type: "tm-delete-view", handler: this.handleDeleteView },
        {type: "tm-store-position", handler: this.handleStorePositions },
        {type: "tm-edit-node-filter", handler: this.handleEditNodeFilter },
        {type: "tm-import-tiddlers", handler: this.handleImportTiddlers }
      ]);
    }

  };
  
  // !! EXTENSION !!
  TaskGraphWidget.prototype = new Widget();
  // !! EXTENSION !!
    
  /**
   * This handler will open a dialog in which the user specifies an
   * edgetype to use to create an edge between to nodes.
   * 
   * Before any result is displayed to the user on the graph, the
   * relationship needs to be persisted in the store for the according
   * edgetype. If that operation was successful, each graph will instantly
   * be aware of the change as it listens to tiddler changes.
   * 
   * @param {Edge} edge - A javascript object that contains at least
   *    the properties "from", "to" and "label"
   * @param {function} [callback] - A function with the signature
   *    function(isConfirmed);
   */
  TaskGraphWidget.prototype.handleConnectionEvent = function(edge, callback) {

    var edgeFilterExpr = this.getView().getAllEdgesFilterExpr(true);

    var vars = {
      edgeFilterExpr: edgeFilterExpr,
      fromLabel: this.adapter.selectNodeById(edge.from).label,
      toLabel: this.adapter.selectNodeById(edge.to).label
    };
    
    this.dialogManager.open(this.opt.ref.edgeTypeDialog, vars, function(isConfirmed, outputTObj) {
    
      if(isConfirmed) {
        
        var text = utils.getText(outputTObj);
        edge.label = (text &amp;&amp; text !== this.opt.misc.unknownEdgeLabel
                      ? text
                      : this.opt.misc.unknownEdgeLabel);

        this.adapter.insertEdge(edge, this.getView());
        
      }
      
      if(typeof callback == "function") {
        callback(isConfirmed);
      }
        
    });
    
  };
  
  /**
   * Promts a dialog that will confront the user with making a tough choice :)
   * @param {function} [callback] - A function with the signature function(isConfirmed).
   * @param {string} [message] - An small optional message to display.
   */
  TaskGraphWidget.prototype.openStandardConfirmDialog = function(callback, message) {
  
    // TODO: option paths seriously need some refactoring!

    var vars = {
      message : message,
      confirmButtonLabel: "Yes mom, I know what I'm doing!",
      cancelButtonLabel: "Uuups, hell no!"
    };
    
    this.dialogManager.open(this.opt.ref.confirmationDialog, vars, callback);
  };
    
  TaskGraphWidget.prototype.logger = function(type, message /*, more stuff*/) {
    
    var args = Array.prototype.slice.call(arguments, 1);
    args.unshift("@" + this.objectId.toUpperCase());
    args.unshift(type);
    $tw.taskgraph.logger.apply(this, args);
    
  };
  
  /**
   * Method to render this widget into the DOM.
   * Attention: BE CAREFUL WITH THE ORDER OF FUNCTION CALLS IN THIS FUNCTION.
   * 
   * @override
   */
  TaskGraphWidget.prototype.render = function(parent, nextSibling) {
    
    // remember our place in the dom
    this.registerParentDomNode(parent);
    
    // who am I?
    this.objectId = (this.getAttribute("object-id")
                     ? this.getAttribute("object-id")
                     : utils.genUUID());
    
    // get view and view holder
    this.viewHolderRef = this.getViewHolderRef();
    this.view = this.getView();
    
    // some views are system views with special meaning 
    this.handleSpecialViews();
        
    // first append the bar if we are in editor mode
    this.initAndRenderEditorBar(parent);
        
    // now initialise graph variables and render the graph
    this.initAndRenderGraph(parent);
    
    // register this graph at the caretaker's graph registry
    $tw.taskgraph.registry.push(this);
    
  };
  
  /**
   * Add some classes to give the user a chance to apply some css
   * to different graph modes.
   */
  TaskGraphWidget.prototype.registerParentDomNode = function(parent) {
    this.parentDomNode = parent;
    if(!$tw.utils.hasClass(parent, "taskgraph")) {
      $tw.utils.addClass(parent, "taskgraph");
      if(this.getAttribute("click-to-use") !== "false") {
        $tw.utils.addClass(parent, "click-to-use");
      }
      if(this.getAttribute("class")) {
        $tw.utils.addClass(parent, this.getAttribute("class"));
      }
    }
  }
  
  TaskGraphWidget.prototype.handleSpecialViews = function() {
    
    if(this.view.getLabel() === "quick_connect") {
      var tRef = "$:/temp/felixhayashi/taskgraph/quick_connect_search";
      this.wiki.setText(tRef, "text", null, ""); // clear
      var filter = "[search{" + tRef + "}!is[system]limit[10]]" + // search
                   "[field:title[" + this.getVariable("currentTiddler") + "]]"; // always
      this.view.setNodeFilter(filter);
    }
    
  };
  
  /**
   * The editor bar contains a bunch of widgets that allow the user
   * to manipulate the current view.
   * 
   * @param {Element} parent The dom node in which the editor bar will
   *     be injected in.
   */
  TaskGraphWidget.prototype.initAndRenderEditorBar = function(parent) {
    
    if(this.editorMode === "advanced") {
    
      this.graphBarDomNode = document.createElement("div");
      $tw.utils.addClass(this.graphBarDomNode, "filterbar");
      parent.appendChild(this.graphBarDomNode);
      
      this.rebuildEditorBar();
      this.renderChildren(this.graphBarDomNode);
      
    }
    
  };

  /**
   * Creates this widget's child-widgets.
   * 
   * @see https://groups.google.com/forum/#!topic/tiddlywikidev/sJrblP4A0o4
   */
  TaskGraphWidget.prototype.rebuildEditorBar = function() {
    
    if(this.editorMode === "advanced") {
    
      // register variables
      this.setVariable("var.viewLabel", this.getView().getLabel());
      this.setVariable("var.isViewBound", String(this.isViewBound()));
      this.setVariable("var.ref.view", this.getView().getRoot());
      this.setVariable("var.ref.viewHolder", this.getViewHolderRef());
      this.setVariable("var.ref.edgeFilter", this.getView().getPaths().edgeFilter);
      this.setVariable("var.edgeFilterExpr", this.view.getAllEdgesFilterExpr());
      
      // Construct the child widget tree
      var body = {
        type: "tiddler",
        attributes: {
          tiddler: { type: "string", value: this.getView().getRoot() }
        },
        children: [{
          type: "transclude",
          attributes: {
            tiddler: { type: "string", value: this.opt.ref.graphBar }
          }
        }]
      };
          
      this.makeChildWidgets([body]);
      
    }
  };
      
  /**
   * This function is called by the system to notify the widget about
   * tiddler changes.
   * 
   * The changes are analyzed by several functions.
   * 
   * 1. checking for callbacks: some processes decided at runtime to 
   * listen to changes of single tiddlers (for example dialogs waiting
   * for results). So at first it is checked if a callback is triggered.
   * 
   * 2. checking for view changes: a view may be replaced (switched)
   * or modified. This will result in recalculation of the graph.
   * 
   * 3. checking for graph refresh: does the graph need an update
   * because nodes/edges have been modified, added or removed or the
   * view has changed?
   * 
   * 4. checking for graphbar refresh: Did some widgets need a rerendering
   * due to changes that affect the topbar (view switched or modified)?
   * 
   * @override Widget.refresh();
   * @see https://groups.google.com/d/msg/tiddlywikidev/hwtX59tKsIk/EWSG9glqCnsJ
   */
  TaskGraphWidget.prototype.refresh = function(changedTiddlers) {
        
    // in any case, check for callbacks triggered by tiddlers
    this.callbackRegistry.handleChanges(changedTiddlers);
    
    var isViewSwitched = this.isViewSwitched(changedTiddlers);
    var viewModifications = this.getView().refresh(changedTiddlers);
            
    if(isViewSwitched) {
    
      this.logger("warn", "View switched");
      this.view = this.getView(true);
      this.rebuildGraph();
    
    } else if(viewModifications.length) {
      
      this.logger("warn", "View modified", viewModifications);
      this.rebuildGraph();
      
    } else {
      
      // check for changes that effect the graph on an element level
      this.checkOnGraph(changedTiddlers);
            
    }
    
    if(this.editorMode) {
      // in any case give child widgets a chance to refresh
      this.checkOnEditorBar(changedTiddlers, isViewSwitched, viewModifications);
    }

  };
  
  /**
   * param {NodeCollection} [nodes] - An optional set of nodes to use
   * instead of the set created according to the nodes filter.
   */
  TaskGraphWidget.prototype.rebuildGraph = function() {
    
    this.logger("debug", "Rebuilding graph");
    
    // always reset to allow handling of stabilized-event!
    this.hasNetworkStabilized = false;
    
    this.graphData = this.getGraphData(true);
    this.network.setData({ nodes: this.graphData.nodes, edges: this.graphData.edges }, this.preventNextRepaint); // true => disableStart
        
    // reset
    this.preventNextRepaint = false;       
  };
  
  TaskGraphWidget.prototype.hasStartedDiving = function() {
    return (this.lastNodeDoubleClicked &amp;&amp; this.getView().isConfEnabled("node_diving"));
  }
  
  /**
   * Warning: Do not change this functionname as it is used by the
   * caretaker's routinely checkups.
   */
  TaskGraphWidget.prototype.getContainer = function() {
    return this.parentDomNode;
  }
  
  /**
   * param {boolean} isRebuild
   * param {NodeCollection} [nodes] - An optional set of nodes to use
   *     instead of the set created according to the nodes filter. Supplying
   *     a nodes collection will always recreate the cache despite the value
   *     of `isRebuild`.
   */
  TaskGraphWidget.prototype.getGraphData = function(isRebuild) {
      
    if(!isRebuild &amp;&amp; this.graphData) {
      return this.graphData;
    }
    
    if(this.hasStartedDiving()) {
      this.lastNodeDoubleClicked.group = "special";
      var nodes = new vis.DataSet([ this.lastNodeDoubleClicked ]);
    } else {      
      var nodeFilter = this.getView().getNodeFilter("compiled");
      var nodes = this.adapter.selectNodesByFilter(nodeFilter, {
        view: this.getView()
      });
    }
    
    var edges = this.adapter.selectEdgesByEndpoints(nodes, {
      view: this.getView(),
      endpointsInSet: ">=1" // ">=1" used to calculate neighbours
    });
    
    if(this.view.getLabel() === "quick_connect") { // special case; ugly solved!
      var curNode = this.adapter.selectNodesByReference([ this.getVariable("currentTiddler") ], {
        outputType: "array",
        addProperties: {
          group: "special",
          x: 1, // WARNING VIS BUG: never use 0 as coordinate!
          y: 1
        }
      });
      
      nodes.update(curNode);
    }
      
    if(this.getView().isConfEnabled("display_neighbours") || this.hasStartedDiving()) {
      var neighbours = this.adapter.selectNeighbours(nodes, {
        edges: edges,
        outputType: "array",
        view: this.getView(),
        addProperties: {
          group: "neighbours"
        }
      });
      utils.inject(neighbours, nodes);
    }
    
    // create data and lookup tables
    var graphData = {
      edges: edges,
      nodes: nodes,
      nodesByRef: utils.getLookupTable(nodes, "ref")
    };
    
    return graphData;
        
  };

  TaskGraphWidget.prototype.isViewBound = function() {
    
    return utils.startsWith(this.getViewHolderRef(),
                            this.opt.path.localHolders);  
    
  };  
  
  TaskGraphWidget.prototype.isViewSwitched = function(changedTiddlers) {
  
    if(this.isViewBound()) {
      return false; // bound views can never be switched!
    } else {
      return utils.hasOwnProp(changedTiddlers, this.getViewHolderRef());
    }
    
  };
  
  /**
   * This method will ckeck if any tw-widget needs a refresh.
   */
  TaskGraphWidget.prototype.checkOnEditorBar = function(changedTiddlers, isViewSwitched, viewModifications) {
    
    // @TODO viewModifications is actually really heavy. I could narrow this.
    if(isViewSwitched || viewModifications.length) {
      
      // full rebuild
      //this.logger("info", "The graphbar needs a full refresh");
      this.removeChildDomNodes();
      // update all variables and build the tree
      this.rebuildEditorBar();
      this.renderChildren(this.graphBarDomNode);
      return true;
      
    } else {
      
      // let children decide for themselves
      //this.logger("info", "Propagate refresh to childwidgets");
      return this.refreshChildren(changedTiddlers);
      
    }
    
  };
  
  /**
   * Rebuild or update the graph if one of the following events occured:
   * 
   * 1. A node that matches the node filter has been added or modified.
   * 2. A node that once matched the node filter has been removed
   * 3. An edge that matches the edge filter has been added or removed.
   * 
   */
  TaskGraphWidget.prototype.checkOnGraph = function(changedTiddlers) {
            
    var nodeFilter = this.getView().getNodeFilter("compiled");
    
    var matchingChangedNodes = utils.getMatches(nodeFilter, Object.keys(changedTiddlers));
                                  
    // check for updated or modified nodes that match the filter
    if(matchingChangedNodes.length) {
      
      this.logger("info", "modified nodes", matchingChangedNodes);
      this.rebuildGraph();
      return;
      
    } else { // no node matches
      
      // check for nodes that do not match the filter anymore
      for(var tRef in changedTiddlers) {
        if(this.graphData.nodesByRef[tRef]) {
          this.logger("info", "obsolete node", matchingChangedNodes);
          this.rebuildGraph();
          return;
          
        }
      }
    }
    
    var edgeFilter = this.getView().getEdgeFilter("compiled");
    var changedEdgestores = utils.getMatches(edgeFilter, Object.keys(changedTiddlers));
    
    if(changedEdgestores.length) {
      
      this.logger("info", "changed edge stores", changedEdgestores);
      this.rebuildGraph();
      return;
    
    }

  };
      
  /**
   * Rebuild the graph
   * 
   * @see
   *   - http://visjs.org/docs/network.html
   *   - http://visjs.org/docs/dataset.html
   */
  TaskGraphWidget.prototype.initAndRenderGraph = function(parent) {
    
    this.logger("info", "Initializing and rendering the graph");
    
    
    if(this.editorMode) {
      // we do **not** register this child via this.children.push(dropZoneWidget);
      // as this would cause the graph to be destroyed on the next refreshWidgets
      var dropZoneWidget = this.makeChildWidget({ type: "dropzone" });
      dropZoneWidget.render(parent); 
      this.graphDomNode = dropZoneWidget.findFirstDomNode();
    } else {
      this.graphDomNode = document.createElement("div");
      parent.appendChild(this.graphDomNode);
    }
    
    $tw.utils.addClass(this.graphDomNode, "vis-graph");
    //parent.appendChild(this.graphDomNode);

    // graph width (assigned to the parent)
    parent.style["width"] = this.getAttribute("width", "100%");
    // graph height (assigned to the vis graph wrapper)
    if(this.getAttribute("height")) {
      this.graphDomNode.style["height"] = this.getAttribute("height");
    } else {
      // the listener removes itself if parentDomNode becomes an orphan
      window.addEventListener("resize", this.handleResizeEvent.bind(this), false);
      // resize now
      this.maxEnlargeGraphContainer();
    }
    
    window.addEventListener("click", this.handleClickEvent.bind(this), false);

    this.graphOptions = this.getGraphOptions();

    // init the graph with dummy data as events are not registered yet
    this.network = new vis.Network(this.graphDomNode,
                                   { nodes: [], edges: [] },
                                   this.graphOptions);
                
    // repaint when sidebar is hidden
    if(!this.editorMode) {
      this.callbackRegistry.add("$:/state/sidebar", this.repaintGraph.bind(this), false);
    }
    
    // listen to refresh-trigger changes if trigger is provided
    if(utils.tiddlerExists(this.getAttribute("refresh-trigger"))) {
      this.callbackRegistry.add(this.getAttribute("refresh-trigger"), function() {
        this.lastNodeDoubleClicked = null; // quits diving mode
        this.rebuildGraph();
      }.bind(this), false);
    }
    
    // register events
    
    this.network.on("doubleClick", this.handleDoubleClickEvent.bind(this));
    this.network.on("stabilized", this.handleStabilizedEvent.bind(this));
    this.network.on('dragStart', this.handleNodeDragStart.bind(this));
    this.network.on("dragEnd", this.handleNodeDragEnd.bind(this));
    
    this.addGraphButtons({
      "surface": function() {
        this.lastNodeDoubleClicked = null;
        this.setGraphButtonEnabled("surface", false);
        this.rebuildGraph();
      }
    });
        
    // finally create and register the data and rebuild the graph
    this.rebuildGraph();
    
    // fix until zoomExtent() works
    var center = this.network.getCenterCoordinates();
    this.network.moveTo({position: center, scale: 0.8});
        
  };
  
  TaskGraphWidget.prototype.getGraphOptions = function() {
    
    // current vis options can be found at $tw.taskgraph.logger("log", this.network.constants);
    
    // get a copy of the options
    var options = this.wiki.getTiddlerData(this.opt.ref.visOptions);
        
    options.onDelete = function(data, callback) {
      this.handleRemoveElement(data);
    }.bind(this);
    options.onConnect = function(data, callback) {
      this.handleConnectionEvent(data);
    }.bind(this);
    options.onAdd = function(data, callback) {
      this.insertNode(data);
    }.bind(this);
    options.onEditEdge = function(data, callback) {
      this.handleReconnectEdge(data);
    }.bind(this);

    options.dataManipulation = {
        enabled : (this.editorMode ? true : false),
        initiallyVisible : (this.view.getLabel() !== "quick_connect"
                            &amp;&amp; this.view.getLabel() !== "search_visualizer")
    };
        
    options.navigation = {
       enabled : true
    };
    
    options.clickToUse = (this.getAttribute("click-to-use") !== "false");
        
    return options;
    
  };
    
  /**
   * Create an empty view. A dialog is opened that asks the user how to
   * name the view. The view is then registered as current view.
   */
  TaskGraphWidget.prototype.handleCreateView = function() {
    
    this.dialogManager.open(this.opt.ref.viewNameDialog, null, function(isConfirmed, outputTObj) {
    
      if(isConfirmed) {
        var view = this.adapter.createView(utils.getText(outputTObj));
        this.setView(view.getRoot());
      }
      
    });
    
  };

  TaskGraphWidget.prototype.handleRenameView = function() {
    
    if(this.getView().getLabel() === "default") {
      $tw.taskgraph.notify("Thou shalt not rename the default view!");
      return;
    }
    
    this.dialogManager.open(this.opt.ref.viewNameDialog, null, function(isConfirmed, outputTObj) {
    
      if(isConfirmed) {
        this.view.rename(utils.getText(outputTObj));
        this.setView(this.view.getRoot());
      }

    });
    
  };

  TaskGraphWidget.prototype.handleDeleteView = function() {
    
    var viewname = this.getView().getLabel();
    
    if(viewname === "default") {
      $tw.taskgraph.notify("Thou shalt not kill the default view!");
      return;
    }
    
    // regex is non-greedy
    var filter = "[regexp:text[&lt;\\$taskgraph.*?view=." + viewname + "..*?>]]";
    var matches = utils.getMatches(filter);
    
    if(matches.length) {
      
      var fields = {
        count : matches.length.toString(),
        filter : filter
      };

      this.dialogManager.open(this.opt.ref.notAllowedToDeleteViewDialog, fields, null);

      return;
      
    }

    var message = "You are about to delete the view " + 
                  "''" + viewname + "'' (no tiddler currently references this view).";
                  
    this.openStandardConfirmDialog(function(isConfirmed) {
      
      if(isConfirmed) {
        this.getView().destroy();
        this.setView(this.opt.path.views + "/default");
        $tw.taskgraph.notify("view \"" + viewname + "\" deleted ");
      }

    }, message);
    
  };
  
  TaskGraphWidget.prototype.handleReconnectEdge = function(updatedEdge) {

    var edge = this.graphData.edges.get(updatedEdge.id);
    $tw.utils.extend(edge, updatedEdge);
    
    this.adapter.deleteEdgesFromStore([
      { id: edge.id, label: edge.label }
    ], this.getView());
    
    this.adapter.insertEdge(edge, this.getView());
    
  };
  
  /**
   * Called by vis when the user tries to delete a node or an edge.
   * 
   * @param {Object} elements - An object containing the elements to be removed.
   * @param {Array&lt;Id>} elements.nodes - Removed edges.
   * @param {Array&lt;Id>} elements.edges - Removed nodes.
   */
  TaskGraphWidget.prototype.handleRemoveElement = function(elements) {
    
    if(elements.edges.length &amp;&amp; !elements.nodes.length) { // only deleting edges
      this.adapter.deleteEdgesFromStore(this.graphData.edges.get(elements.edges), this.getView());
      $tw.taskgraph.notify("edge" + (elements.edges.length > 1 ? "s" : "") + " removed");
    }
                        
    if(elements.nodes.length) {
      
      var fields = {
        subtitle : "Please confirm your choice",
        text: "By deleting a node you are also deleting the " +
              "corresponding tiddler __and__ any edges connected " +
              "to that node. Really proceed?"
      };
      
      this.dialogManager.open(null, fields, function(isConfirmed) {
        
        if(!isConfirmed) return; // callback({}) ?
          
          // get objects with labels and ids
          var nodes = this.graphData.nodes.get(elements.nodes);
          var edges = this.graphData.edges.get(elements.edges);
          
          this.adapter.deleteNodesFromStore(nodes);
          this.adapter.deleteEdgesFromStore(edges, this.getView());
          
          $tw.taskgraph.notify("node" + (elements.nodes.length > 1 ? "s" : "") + " removed");
        
      });
    }     
  }
  
  TaskGraphWidget.prototype.handleImportTiddlers = function(event) {
    
    //var pos = this.network.DOMtoCanvas($tw.taskgraph.mouseDropPos);
    var pos = this.network.getCenterCoordinates();
    var tiddlers = JSON.parse(event.param);
        
    for(var i = 0; i &lt; tiddlers.length; i++) {
      var tObj = this.wiki.getTiddler(tiddlers[i].title);
      
      if(!tObj) {
        this.notify("Cannot integrate foreign tiddler");
        return;
      }
      
      if(utils.isMatch(tObj, this.getView().getNodeFilter("compiled"))) { // no dublicates
        this.notify("Node already exists");
        continue;
      }
      
      var node = this.adapter.createNode(tObj, {
        //~ x: ((i * 20) + pos.x), // if more than one, create some space
        //~ y: pos.y,
      });
      
      if(node) { // only tiddlers that already exist in the wiki
        
        //this.preventNextRepaint = true;
        this.getView().addNodeToView(node);
        this.rebuildGraph();
        
      }
    }
    
  };
  
  TaskGraphWidget.prototype.handleStorePositions = function() {
    this.adapter.storePositions(this.network.getPositions(), this.getView());
    $tw.taskgraph.notify("positions stored");
  };
  
  TaskGraphWidget.prototype.handleEditNodeFilter = function() {

    var fields = {
      prettyFilter: this.getView().getPrettyNodeFilterExpr()
    };
    
    this.dialogManager.open(this.opt.ref.editNodeFilter, fields, function(isConfirmed, outputTObj) {
      if(isConfirmed) {
        this.getView().setNodeFilter(utils.getText(outputTObj));
      }
    });
      
  };

  /**
   * Called by vis when the graph has stabilized itself.
   * 
   * ATTENTION: never store positions in a views map during stabilize
   * as this will affect other graphs positions and will cause recursion!
   * Storing positions inside vis' nodes is fine though
   */
  TaskGraphWidget.prototype.handleStabilizedEvent = function(properties) {
    
    if(!this.hasNetworkStabilized) {
      this.hasNetworkStabilized = true;
      this.logger("log", "Network stabilized after " + properties.iterations + " iterations");
      this.setNodesMoveable(this.graphData.nodes.getIds(),
                            this.getView().isConfEnabled("physics_mode"));
    }
    
  };
  
  /**
   * Allow the given nodes to be moveable.
   * 
   * @param {vis.DataSet} nodes - The nodes for which to allow any
   *     movement (either by physics or by dragging).
   * @param {boolean} isEnabled - True, if the nodes are allowed to
   *     move or be moved.
   */    
  TaskGraphWidget.prototype.setNodesMoveable = function(ids, isMoveable) {

    //this.logger("log", "Nodes", ids, "can move:", isMoveable);
    
    this.network.storePositions(); // does it matter if we put this before setter? yes, I guess.

    var updates = [];
    for(var i = 0; i &lt; ids.length; i++) {
      
      updates.push({
        id: ids[i],
        allowedToMoveX: isMoveable,
        allowedToMoveY: isMoveable
      });
      
    }
    
    this.graphData.nodes.update(updates);

  };

  TaskGraphWidget.prototype.insertNode = function(node) {
    this.preventNextRepaint = true;
    this.adapter.insertNode(node, {
      view: this.getView(),
      editNodeOnCreate: false
    });
  };
    
  /**
   * This handler is registered at and called by the vis network event
   * system
   * 
   * @see
   *   - Coordinates not passed on click/tap events within the properties object
   *     https://github.com/almende/vis/issues/440
   * 
   * @properties a list of nodes and/or edges that correspond to the
   * click event.
   */
  TaskGraphWidget.prototype.handleDoubleClickEvent = function(properties) {
    
    if(!properties.nodes.length &amp;&amp; !properties.edges.length) { // clicked on an empty spot
      
      if(!this.editorMode) {
        return;
      }
      
      this.dialogManager.open(this.opt.ref.nodeNameDialog, null, function(isConfirmed, outputTObj) {
        if(isConfirmed) {
          var node = properties.pointer.canvas;
          node.label = utils.getText(outputTObj);
          this.insertNode(node);
        }
      });
      
    } else {
      
       if(properties.nodes.length) { // clicked on a node
         
        var node = this.graphData.nodes.get(properties.nodes[0]);
        this.logger("debug", "Doubleclicked on node", node);        
        this.lastNodeDoubleClicked = node;
        var tRef = node.ref;
        
        if(this.getView().isConfEnabled("node_diving")) {
          this.setGraphButtonEnabled("surface", true);
          var time = 2000;
          
          this.preventNextRepaint = true;
          this.rebuildGraph();
          this.network.zoomExtent({
            duration: time
          });
        }
        
      } else if(properties.edges.length) { // clicked on an edge
        
        this.logger("debug", "Doubleclicked on an Edge");
        
        // TODO: open option menu
        var edge = this.graphData.edges.get(properties.edges[0]);
        var label = (edge.label
                     ? edge.label
                     : this.opt.misc.unknownEdgeLabel);
        var tRef = this.getView().getEdgeStoreLocation() + "/" + label;
      
      }
      
      // window.location.hash = node.ref; is not the right way to do it
      this.dispatchEvent({
        type: "tm-navigate", navigateTo: tRef
      }); 
            
    }
    
  };
  
  /**
   * Listener will be removed if the parent is not part of the dom anymore
   * 
   * @see
   *   - [TW5] Is there a destructor for widgets?
   *     https://groups.google.com/d/topic/tiddlywikidev/yuQB1KwlKx8/discussion
   *   - https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
   */
  TaskGraphWidget.prototype.handleResizeEvent = function(event) {

    if(this.network) {
      this.maxEnlargeGraphContainer(); // resize container
      this.repaintGraph(); // redraw graph
    }
    
  };
  
  /**
   * called from outside.
   */
  TaskGraphWidget.prototype.destruct = function() {
    window.removeEventListener("resize", this.handleResizeEvent);
    this.network.destroy();
  };
  
  /**
   * used to prevent nasty deletion as edges are not unselected when leaving vis
   */
  TaskGraphWidget.prototype.handleClickEvent = function(event) {

    if(!document.body.contains(this.parentDomNode)) {
      window.removeEventListener("click", this.handleClickEvent);
      return;
    }
    
    if(this.network) {
      var element = document.elementFromPoint(event.clientX, event.clientY);
      if(!this.parentDomNode.contains(element)) {
        this.network.selectNodes([]);
      }
    }

  };
  
  /**
   * Called by vis when the dragging of a node(s) has ended.
   * @param {Object} properties - A vis object containing event-related
   *     information.
   * @param {Array&lt;Id>} properties.nodeIds - Array of ids of the nodes
   *     that were being dragged.
   */
  TaskGraphWidget.prototype.handleNodeDragEnd = function(properties) {
    if(properties.nodeIds.length &amp;&amp; !this.hasStartedDiving()) {
      var mode = this.getView().isConfEnabled("physics_mode");
      this.setNodesMoveable([ properties.nodeIds[0] ], mode);
      this.handleStorePositions();
    }
  };
  
  /**
   * Called by vis when a node is being dragged.
   * @param {Object} properties - A vis object containing event-related
   *     information.
   * @param {Array&lt;Id>} properties.nodeIds - Array of ids of the nodes
   *     that are being dragged.
   */
  TaskGraphWidget.prototype.handleNodeDragStart = function(properties) {
    if(properties.nodeIds.length) {
      this.setNodesMoveable([ properties.nodeIds[0] ], true);
    }
  };
   
  /**
   * The view holder is a tiddler that stores a references to the current
   * view. If the graph is not bound to a view by the user via an
   * attribute, the default view holder is used. Otherwise, a temporary
   * holder is created whose value is set to the view specified by the user.
   * This way, the graph is independent from view changes made in a
   * taskgraph editor.
   * 
   * This function will only calculate a new reference to the holder
   * on first call (that is when no view holder is registered to "this".
   * 
   */
  TaskGraphWidget.prototype.getViewHolderRef = function() {
    
    // the viewholder is never recalculated once it exists
    if(this.viewHolderRef) {
      return this.viewHolderRef;
    }
    
    this.logger("info", "Retrieving or generating the view holder reference");
    
    // if given, try to retrieve the viewHolderRef by specified attribute
    var viewName = this.getAttribute("view");
    if(viewName) {
      
      this.logger("log", "User wants to bind view \"" + viewName + "\" to graph");
            
      var viewRef = this.opt.path.views + "/" + viewName;
      if(this.wiki.getTiddler(viewRef)) {
        
        // create a view holder that is exclusive for this graph
        
        var holderRef = this.opt.path.localHolders + "/" + utils.genUUID();
        this.logger("log", "Created an independent temporary view holder \"" + holderRef + "\"");
        
        // we do not use setView here because it would store and reload the view unnecessarily...
        this.wiki.addTiddler(new $tw.Tiddler({ 
          title: holderRef,
          text: viewRef
        }));
        
        this.logger("log", "View \"" + viewRef + "\" inserted into independend holder");
        
      } else {
        this.logger("log", "View \"" + viewName + "\" does not exist");
      }
      
    }
    
    if(typeof holderRef === "undefined") {
      this.logger("log", "Using default (global) view holder");
      var holderRef =  this.opt.ref.defaultGraphViewHolder;
    }
    
    return holderRef;
    
  };
  
  /**
   * This function will switch the current view reference of the
   * view holder. If no viewRef is specified, the current view is
   * simply updated.
   * 
   * @viewRef (optional) a reference (tiddler title) to a view
   * @viewHolderRef (optional) a reference to the view holder that should be updated
   */
  TaskGraphWidget.prototype.setView = function(viewRef, viewHolderRef) {
    
    if(viewRef) {
      if(!viewHolderRef) {
        viewHolderRef = this.viewHolderRef;
      }
      this.logger("info", "Inserting view \"" + viewRef + "\" into holder \"" + viewHolderRef + "\"");
      this.wiki.addTiddler(new $tw.Tiddler({ 
        title : viewHolderRef,
        text : viewRef
      }));
    }
    
    // register the new value; no need to update the adapter as this is done during refresh
    this.view = this.getView(true);
  };
  
  /**
   * This function will return a view abstraction that is based on the
   * view specified in the view holder of this graph.
   * 
   * @param {boolean} isRebuild - Retrieve the view reference again
   *     from the holder and recreate the view abstraction object.
   * @return {ViewAbstraction} the view
   */
  TaskGraphWidget.prototype.getView = function(isRebuild) {
    
    if(!isRebuild &amp;&amp; this.view) {
      return this.view;
    }
    
    var viewHolderRef = this.getViewHolderRef();
    var curViewRef = this.wiki.getTiddler(viewHolderRef).fields.text;
    this.logger("info", "Retrieved view \"" + curViewRef + "\" from holder \"" + viewHolderRef + "\"");
    
    if(utils.tiddlerExists(curViewRef)) {
      return new ViewAbstraction(curViewRef);
    } else {
      this.logger("log", "Warning: View \"" + curViewRef + "\" doesn't exist. Default is used instead.");
      return new ViewAbstraction("default");
    }
    
  };
    
  TaskGraphWidget.prototype.repaintGraph = function() {
    
    this.logger("info", "Repainting the whole graph");
    
    this.network.redraw();
    this.network.zoomExtent();
    
  };
  
  /**
   * This will make the container dom element stretch to the bottom
   * of the page.
   */
  TaskGraphWidget.prototype.maxEnlargeGraphContainer = function() {

    var windowHeight = window.innerHeight;
    var canvasOffset = utils.getDomNodePos(this.graphDomNode).y;
    var distanceBottom = this.getAttribute("bottom-spacing", "10px");
    var calculatedHeight = (windowHeight - canvasOffset) + "px";
    
    this.graphDomNode.style["height"] = "calc(" + calculatedHeight + " - " + distanceBottom + ")";
    
  };
  
  /**
   * If a button is enabled it means it is displayed on the graph canvas.
   * 
   * @param {string} name - The name of the button to enabled. Has to
   *     correspond with the css button name.
   * @param {boolean} enable - True if the button should be visible,
   *     false otherwise.
   */ 
  TaskGraphWidget.prototype.setGraphButtonEnabled = function(name, enable) {
    var className = "network-navigation taskgraph-button " + name;
    var b = this.parentDomNode.getElementsByClassName(className)[0];
    $tw.utils.toggleClass(b, "enabled", enable);
  }; 

  /**
   * This function will create the dom elements for all taskgraph-vis
   * buttons and register the event listeners.
   * 
   * @param {Object&lt;string, function>} buttonEvents - The label of the
   *     button that is used as css class and the click handler.
   */
  TaskGraphWidget.prototype.addGraphButtons = function(buttonEvents) {
    
    var parent = this.parentDomNode.getElementsByClassName("vis network-frame")[0];
    
    for(var name in buttonEvents) {
      var div = document.createElement("div");
      div.className = "network-navigation taskgraph-button " + name;
      div.addEventListener("click", buttonEvents[name].bind(this), false);
      parent.appendChild(div);
    }
    
  };
  
  // !! EXPORT !!
  exports.taskgraph = TaskGraphWidget;
  // !! EXPORT !!
  
})();

</pre>
	</article>
</section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		Copyright Â© 2014 FelixHayashi
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha11</a>
		on 2014-12-28T01:16:31+01:00 using the <a
			href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<!--<script src="scripts/sunlight.js"></script>-->
	<script src="scripts/docstrap.lib.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>

	<script>
		$( function () {
			$( "[id*='$']" ).each( function () {
				var $this = $( this );

				$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
			} );

			$( "#toc" ).toc( {
				anchorName  : function ( i, heading, prefix ) {
					return $( heading ).attr( "id" ) || ( prefix + i );
				},
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : "100px"
			} );

			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
			$( '.dropdown-toggle' ).dropdown();
//			$( ".tutorial-section pre, .readme-section pre" ).addClass( "sunlight-highlight-javascript" ).addClass( "linenums" );

			$( ".tutorial-section pre, .readme-section pre" ).each( function () {
				var $this = $( this );

				var example = $this.find( "code" );
				exampleText = example.html();
				var lang = /{@lang (.*?)}/.exec( exampleText );
				if ( lang && lang[1] ) {
					exampleText = exampleText.replace( lang[0], "" );
					example.html( exampleText );
					lang = lang[1];
				} else {
					lang = "javascript";
				}

				if ( lang ) {

					$this
						.addClass( "sunlight-highlight-" + lang )
						.addClass( "linenums" )
						.html( example.html() );

				}
			} );

			Sunlight.highlightAll( {
				lineNumbers : true,
				showMenu : true,
				enableDoclinks : true
			} );
		} );
	 </script>



	<!--Navigation and Symbol Display-->
	


	<!--Google Analytics-->
	

</body>
</html>
